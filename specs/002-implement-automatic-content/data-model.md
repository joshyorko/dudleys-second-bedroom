# Data Model: Automatic Content-Based Versioning

**Feature**: 002-implement-automatic-content  
**Date**: 2025-10-10  
**Status**: Complete

## Overview

This document defines the data structures, relationships, and validation rules for the content-based versioning system. The system operates at two distinct phases: build-time (manifest generation) and runtime (manifest consumption).

---

## Core Entities

### 1. ContentHash

**Description**: An 8-character truncated SHA256 hash representing the current state of one or more files.

**Structure**:
```bash
# Type: String
# Format: 8 lowercase hexadecimal characters
# Example: "8f7a2c3d"
```

**Validation Rules**:
- MUST be exactly 8 characters
- MUST contain only hexadecimal characters [a-f0-9]
- MUST be deterministic (same input → same output)
- MUST be computed from sorted file paths (for multi-file hashes)

**Generation**:
```bash
compute_content_hash() {
    local files=("$@")
    
    # Validate files exist
    for file in "${files[@]}"; do
        [[ -f "$file" ]] || { echo "ERROR: File not found: $file" >&2; exit 1; }
    done
    
    # Sort for determinism
    IFS=$'\n' sorted_files=($(sort <<<"${files[*]}"))
    unset IFS
    
    # Compute hash
    cat "${sorted_files[@]}" | sha256sum | cut -c1-8
}
```

**Relationships**:
- One ContentHash per HookVersion
- Derived from one or more dependency files

**State Transitions**: None (immutable after computation)

---

### 2. HookVersion

**Description**: Metadata about a specific user hook's version and dependencies.

**Structure**:
```json
{
  "version": "8f7a2c3d",
  "dependencies": [
    "build_files/user-hooks/20-vscode-extensions.sh",
    "vscode-extensions.list"
  ],
  "metadata": {
    "extension_count": 15,
    "changed": true
  }
}
```

**Fields**:

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|------------|
| `version` | string | Yes | 8-char ContentHash | Pattern: `^[a-f0-9]{8}$` |
| `dependencies` | array[string] | Yes | File paths used in hash | Min 1 item, paths must exist at build time |
| `metadata` | object | No | Hook-specific data | Extensible, no fixed schema |

**Validation Rules**:
- `dependencies` array MUST NOT be empty
- All dependency paths MUST be relative to repository root
- `metadata` object CAN contain any valid JSON values
- `version` MUST match hash of concatenated dependencies

**Common Metadata Fields** (hook-specific):
- `extension_count` (vscode-extensions): Number of extensions in list
- `wallpaper_count` (wallpaper): Number of wallpaper files
- `changed` (all hooks): Boolean indicating if version differs from previous build

**Relationships**:
- One HookVersion per hook per build
- Contains one ContentHash (version field)
- Referenced by BuildManifest

**State Transitions**:
```
[Build Time]
  1. Dependencies identified → version UNSET
  2. Hash computed → version SET
  3. Metadata populated → COMPLETE
  4. Written to manifest → PERSISTED

[Runtime]
  Immutable (read-only)
```

---

### 3. BuildManifest

**Description**: Complete metadata about an image build, including all hook versions and build environment details.

**Structure**:
```json
{
  "version": "1.0.0",
  "build": {
    "date": "2025-10-10T14:30:00Z",
    "image": "ghcr.io/joshyorko/dudleys-second-bedroom:latest",
    "base": "ghcr.io/ublue-os/bluefin-dx:40",
    "commit": "a3f2c1b"
  },
  "hooks": {
    "vscode-extensions": { /* HookVersion */ },
    "wallpaper": { /* HookVersion */ },
    "welcome": { /* HookVersion */ }
  }
}
```

**Fields**:

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|------------|
| `version` | string | Yes | Manifest schema version | Semver pattern: `^\d+\.\d+\.\d+$` |
| `build` | object | Yes | Build environment metadata | See BuildInfo below |
| `hooks` | object | Yes | Map of hook name → HookVersion | Keys: alphanumeric + dashes/underscores |

**BuildInfo Substructure**:

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|------------|
| `date` | string | Yes | Build timestamp | ISO 8601 format (UTC recommended) |
| `image` | string | Yes | Full image name with tag | Valid OCI image reference |
| `base` | string | Yes | Base image reference | Valid OCI image reference |
| `commit` | string | Yes | Git commit SHA | 7 or 40 hex characters |

**Validation Rules**:
- Total JSON size MUST be < 50KB
- `hooks` object MUST contain at least one entry
- All HookVersion entries MUST be valid per HookVersion schema
- `version` field enables schema evolution (current: 1.0.0)
- `build.date` MUST be valid ISO 8601 timestamp
- `build.commit` SHOULD be retrievable from git during build

**Storage**:
- Build time: Generated by `manifest-builder.sh`
- Runtime: `/etc/dudley/build-manifest.json` (immutable, world-readable, 644 permissions)

**Relationships**:
- Contains multiple HookVersion entries
- One BuildManifest per image build
- Referenced by welcome hook for display

**State Transitions**:
```
[Build Time]
  1. Initialized with schema version → EMPTY
  2. Build metadata populated → BUILD_INFO_SET
  3. Each HookVersion added → ACCUMULATING
  4. Written to file → COMPLETE
  5. Copied to /etc/dudley/ → DEPLOYED

[Runtime]
  Immutable (read-only)
```

---

## Data Flow Diagrams

### Build-Time Flow

```
Repository Files
    ├── vscode-extensions.list ─┐
    ├── 20-vscode-extensions.sh ─┴─> compute_content_hash() ─> ContentHash "8f7a2c3d"
    │                                                                  │
    ├── custom_wallpapers/*.jpg ─┬─> compute_content_hash() ─> ContentHash "1c4e9f2a"
    ├── 10-wallpaper-enforcement.sh                                    │
    │                                                                  │
    └── 99-first-boot-welcome.sh ──> compute_content_hash() ─> ContentHash "5b8d3e1f"
                                                                       │
                                                    ┌──────────────────┘
                                                    ↓
                                            HookVersion Objects
                                                    │
                    ┌───────────────────────────────┴────────────────────────────┐
                    ↓                                                              ↓
            manifest-builder.sh                                           BuildInfo
                    │                                                       (git, env)
                    │                                                              │
                    └───────────────────────> BuildManifest <─────────────────────┘
                                                    │
                                                    ↓
                                    /etc/dudley/build-manifest.json
```

### Runtime Flow

```
User Boot
    │
    └─> ublue-user-setup.service
            │
            ├─> 10-wallpaper-enforcement.sh
            │       ├─> version-script "wallpaper" "1c4e9f2a"
            │       └─> [run if changed]
            │
            ├─> 20-vscode-extensions.sh
            │       ├─> version-script "vscode-extensions" "8f7a2c3d"
            │       └─> [run if changed]
            │
            └─> 99-first-boot-welcome.sh
                    ├─> version-script "welcome" "5b8d3e1f"
                    ├─> jq -r .hooks /etc/dudley/build-manifest.json
                    └─> Display summary (always runs, reads manifest)
```

---

## Validation Rules Summary

### Build-Time Validation

| Rule | Severity | Check |
|------|----------|-------|
| All dependency files exist | ERROR | Fail build if missing |
| ContentHash is 8 hex chars | ERROR | Regex validation |
| Manifest is valid JSON | ERROR | `jq` parse test |
| Manifest < 50KB | WARNING | File size check |
| Git commit available | WARNING | Fallback to "unknown" |
| All hooks have versions | ERROR | Non-empty hooks object |

### Runtime Validation

| Rule | Severity | Check |
|------|----------|-------|
| Manifest file exists | WARNING | Graceful degradation if missing |
| Manifest is parseable JSON | WARNING | `jq` error handling |
| Hook version format valid | INFO | Log warning, continue anyway |

**Note**: Runtime validation is lenient because manifest issues indicate build problems that should have been caught earlier. Production images should never have invalid manifests.

---

## Extensibility Points

### Adding New Hooks

1. Define hook name (kebab-case recommended)
2. List dependencies (script + data files)
3. Compute ContentHash in build script
4. Add HookVersion entry to manifest
5. Populate hook-specific metadata (optional)

**Example**:
```json
"flatpak-install": {
  "version": "a1b2c3d4",
  "dependencies": [
    "build_files/user-hooks/30-flatpak-install.sh",
    "flatpaks/system-flatpaks.list"
  ],
  "metadata": {
    "flatpak_count": 8,
    "changed": true
  }
}
```

### Schema Evolution

Future schema versions can add fields without breaking compatibility:
- New top-level fields (e.g., `"packages": {...}`)
- New BuildInfo fields (e.g., `"builder": "github-actions"`)
- New HookVersion metadata fields (per-hook basis)

Version 2.x could add:
- Package change tracking (`"packages": { "added": [...], "removed": [...] }`)
- Differential hook information (`"previous_version": "..."`)
- Build performance metrics (`"build_duration_seconds": 120`)

---

## Schema Definition (JSON Schema)

Full JSON Schema available at: `contracts/build-manifest-schema.json`

Quick reference:
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Dudley Build Manifest",
  "version": "1.0.0",
  "description": "Content-based version tracking for user hooks",
  "type": "object",
  "required": ["version", "build", "hooks"],
  "additionalProperties": false
}
```

---

## Implementation Notes

### Hash Computation Considerations

**File Ordering**: Always sort file paths before hashing to ensure determinism across different shell glob expansions.

**Binary Files**: `cat` handles binary files correctly; no special processing needed for wallpaper images.

**Symbolic Links**: Resolve symlinks before hashing to track actual content, not link targets.

**Large Files**: For files >10MB, consider adding progress indication in build output (though current scope doesn't include such files).

### Manifest Generation Best Practices

**Atomicity**: Generate manifest in temporary file, then move to final location (prevents partial writes).

**Pretty Printing**: Use `jq .` for human-readable formatting (aids debugging without affecting functionality).

**Error Handling**: Use `set -euo pipefail` in manifest-builder.sh to fail fast on any error.

**Testing**: Validate generated manifest against JSON schema in test suite.

### Version Recording Integration

**Timing**: version-script records version only after successful hook completion (exit 0).

**Location**: Version files stored at `/etc/ublue/version-script/<hook-name>` (managed by version-script function).

**Persistence**: Version files persist across reboots on mutable `/etc` (OSTree architecture detail).

**Reset**: Users can manually delete version files to force hook re-execution (documented recovery procedure).

---

## Summary

The data model provides a simple, flat structure optimized for bash/jq processing while maintaining extensibility for future enhancements. Key design principles:

- **Immutability**: All entities are immutable after creation
- **Determinism**: Hash computation is repeatable and predictable
- **Transparency**: Dependencies explicitly listed for debugging
- **Extensibility**: Metadata fields allow per-hook customization without schema changes
- **Validation**: Strict at build time, lenient at runtime (fail-fast philosophy)

This model supports the core requirement of automatic versioning while providing visibility into what changed and why hooks execute.
